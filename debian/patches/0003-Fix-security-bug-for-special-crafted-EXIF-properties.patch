From 330eb4864502ebbad4da4680471cee260766b19b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bastien=20ROUCARI=C3=88S?= <roucaries.bastien@gmail.com>
Date: Wed, 11 Apr 2012 11:22:19 +0200
Subject: [PATCH 3/3] Fix security bug for special crafted EXIF properties

The original patch for CVE-2012-0259 turned out to be insufficient.

The problem is an integer overflow error in the "GetEXIFProperty()"
function (magick/property.c, around line 1288):

number_bytes=(size_t) components*tag_bytes[format];

When processing EXIF directory entries with tags of e.g. format 5
EXIF_FMT_URATIONAL) and a large components count, the calculation can
overflow and e.g. lead to "number_bytes" being 0. If that's the case,
subsequent checks can be bypassed, resulting in the loop in the
"EXIFMultipleFractions" macro to iterate through a large number of
"components". This leads to out-of-bound reads until eventually causing
a segmentation fault when trying to read beyond the limits of heap memory.

CVE-2012-1610 has been assigned to this issue.

Note: The initial patch for this issue is still necessary to prevent
access of uninitialized/incorrect memory when e.g. processing specially
crafted EXIF tags with a component count of 0.

Origin: upstream
Applied-Upstream: 6.7.6-4
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=667635
---
 magick/profile.c  |    7 +++++--
 magick/property.c |    4 ++--
 2 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/magick/profile.c b/magick/profile.c
index 92e56f4..28cbeab 100644
--- a/magick/profile.c
+++ b/magick/profile.c
@@ -1843,8 +1843,9 @@ MagickExport MagickBooleanType SyncImageProfiles(Image *image)
     number_entries=ReadProfileShort(endian,directory);
     for ( ; entry < number_entries; entry++)
     {
+      ssize_t
+        components;
       long
-        components,
         format,
         tag_value;
 
@@ -1863,8 +1864,10 @@ MagickExport MagickBooleanType SyncImageProfiles(Image *image)
       format=(long) ReadProfileShort(endian,q+2);
       if ((format-1) >= EXIF_NUM_FORMATS)
         break;
-      components=(long) ReadProfileLong(endian,q+4);
+      components=(ssize_t) ((int) ReadProfileLong(endian,q+4));
       number_bytes=(size_t) components*format_bytes[format];
+      if (number_bytes < components)
+        break;  /* prevent overflow */
       if (number_bytes <= 4)
         p=q+8;
       else
diff --git a/magick/property.c b/magick/property.c
index 9bde6f3..cd3d153 100644
--- a/magick/property.c
+++ b/magick/property.c
@@ -1284,7 +1284,7 @@ static MagickBooleanType GetEXIFProperty(const Image *image,
     number_entries=(size_t) ((int) ReadPropertyShort(endian,directory));
     for ( ; entry < number_entries; entry++)
     {
-      long
+      ssize_t
         components;
 
       register unsigned char
@@ -1305,7 +1305,7 @@ static MagickBooleanType GetEXIFProperty(const Image *image,
       format=(size_t) ((int) ReadPropertyShort(endian,q+2));
       if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))
         break;
-      components=(long) ReadPropertyLong(endian,q+4);
+      components=(ssize_t) ((int) ReadPropertyLong(endian,q+4));
       number_bytes=(size_t) components*tag_bytes[format];
       if (number_bytes < components)
         break;  /* prevent overflow */
-- 
1.7.9.1

